<!DOCTYPE html>
<meta charset="UTF-8">
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/danfojs@0.3.3/lib/bundle.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.2.0.min.js"></script>

<style>
    .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 3px;
    }

    .node text {
        font: 12px sans-serif;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
    }
</style>

<body>
    <div id="tree-container"></div>
    <div id="bar-container"></div>
    <script>

        // create 2 data_set
        const data_bar = [
            { group: "A", value: 4 },
            { group: "B", value: 16 },
            { group: "C", value: 8 },
            { group: "D", value: 2 },
            { group: "E", value: 3 }
        ];


        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 60 },
            width = 800 - margin.left - margin.right,
            height = 300 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg = d3.select("#bar-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // X axis
        const x = d3.scaleBand()
            .range([0, width])
            .domain(data_bar.map(d => d.group))
            .padding(0.2);
        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))

        // Add Y axis


        updatebar(data_bar)
        // A function that create / update the plot for a given variable:
        function updatebar(data) {

            var ymax = 0;
            console.log(data);
            for (i = 0; i < data.length; i++) {
                if (ymax < data[i]['value']) {
                    ymax = data[i]['value']

                }

            }
            ymax = Math.ceil(ymax / 10) * 10
            d3.select(".myYaxis").remove();
            var y = d3.scaleLinear()
                .domain([0, Math.max(20, ymax)])
                .range([height, 0]);
            svg.append("g")
                .attr("class", "myYaxis")
                .call(d3.axisLeft(y));

            var u = svg.selectAll("rect")
                .data(data)

            u
                .join("rect")
                .transition()
                .duration(1000)
                .attr("x", d => x(d.group))
                .attr("y", d => y(d.value))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.value))
                .attr("fill", "#69b3a2")
        }

        // Initialize the plot with the first dataset

        tree()
        let status = {
            "school": true,
            "MS": false,
            "GP": false,
            "Sex-M": false,
            "Sex-F": false,
            "higher-no": false,
            "higher-yes": false
        }
        function tree() {
            var treeData =
            {
                "name": "school",
                "children": [
                    {
                        "name": "MS",
                        "children": [
                            {
                                "name": "Sex-M",
                                "children": [{ "name": "higher-no" }, { "name": "higher-yes" }]
                            },
                            {
                                "name": "Sex-F",
                                "children": [{ "name": "higher-no" }, { "name": "higher-yes" }]
                            }
                        ]
                    },
                    {
                        "name": "GP",
                        "children": [
                            {
                                "name": "Sex-M",
                                "children": [{ "name": "higher-no" }, { "name": "higher-yes" }]
                            },
                            {
                                "name": "Sex-F",
                                "children": [{ "name": "higher-no" }, { "name": "higher-yes" }]
                            }
                        ]
                    }
                ]
            };

            // Set the dimensions and margins of the diagram
            var margin = { top: 10, right: 90, bottom: 30, left: 90 },
                width = 1000 - margin.left - margin.right,
                height = 350 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            // appends a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            var svg = d3.select("#tree-container").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("id", "g1")
                .attr("transform", "translate("
                    + margin.left + "," + margin.top + ")");

            var i = 0,
                duration = 750,
                root;

            // declares a tree layout and assigns the size
            var treemap = d3.tree().size([height, width]);

            // Assigns parent, children, height, depth
            root = d3.hierarchy(treeData, function (d) { return d.children; });
            root.x0 = height / 2;
            root.y0 = 0;

            // Collapse after the second level
            root.children.forEach(collapse);
            update(root);


            // Collapse the node and all it's children
            function collapse(d) {
                if (d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }


            function update(source) {

                // Assigns the x and y position for the nodes
                var treeData = treemap(root);

                // Compute the new tree layout.
                var nodes = treeData.descendants(),
                    links = treeData.descendants().slice(1);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) { d.y = d.depth * 180 });

                // ****************** Nodes section ***************************

                // Update the nodes...
                var node = svg.selectAll('g.node')
                    .data(nodes, function (d) { return d.id || (d.id = ++i); });

                // Enter any new modes at the parent's previous position.
                var nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click);

                // Add Circle for the nodes
                nodeEnter.append('circle')
                    .attr('class', 'node')
                    .attr('r', 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    });

                // Add labels for the nodes
                nodeEnter.append('text')
                    .attr("dy", ".35em")
                    .attr("x", function (d) {
                        return d.children || d._children ? -13 : 13;
                    })
                    .attr("text-anchor", function (d) {
                        return d.children || d._children ? "end" : "start";
                    })
                    .text(function (d) { return d.data.name; });

                // UPDATE
                var nodeUpdate = nodeEnter.merge(node);

                // Transition to the proper position for the node
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                // Update the node attributes and style
                nodeUpdate.select('circle.node')
                    .attr('r', 10)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                // Remove any exiting nodes
                var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                // On exit reduce the node circles size to 0
                nodeExit.select('circle')
                    .attr('r', 1e-6);

                // On exit reduce the opacity of text labels
                nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                // ****************** links section ***************************

                // Update the links...
                var link = svg.selectAll('path.link')
                    .data(links, function (d) { return d.id; });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', function (d) {
                        var o = { x: source.x0, y: source.y0 }
                        return diagonal(o, o)
                    });

                // UPDATE
                var linkUpdate = linkEnter.merge(link);

                // Transition back to the parent element position
                linkUpdate.transition()
                    .duration(duration)
                    .attr('d', function (d) { return diagonal(d, d.parent) });

                // Remove any exiting links
                var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        var o = { x: source.x, y: source.y }
                        return diagonal(o, o)
                    })
                    .remove();

                // Store the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Creates a curved (diagonal) path from parent to the child nodes
                function diagonal(s, d) {

                    path = `M ${s.y} ${s.x}
                            C ${(s.y + d.y) / 2} ${s.x},
                              ${(s.y + d.y) / 2} ${d.x},
                              ${d.y} ${d.x}`

                    return path
                }



                // Toggle children on click.
                function click(event, d) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                    upstatus(d);
                    updata()
                }

                function upstatus(d) {

                    if (d._children) {
                        // expand
                        d.descendants().forEach(function (d) { status[d.data.name] = false; });
                    } else {
                        // collasp
                        status[d.data.name] = true;
                    }
                }
                function updata() {
                    dfd.read_csv("https://raw.githubusercontent.com/gbZachYin/StuPerfAnalysis/main/data/stu-mat.csv")
                        .then(df => {

                            if (status["MS"]) {
                                df = df.query({ column: "school", is: "==", to: "MS" })
                            }

                            if (status["GP"]) {
                                df = df.query({ column: "school", is: "==", to: "GP" })
                            }

                            if (status["Sex-M"]) {
                                df = df.query({ column: "1", is: "==", to: "M" });
                            }

                            if (status["Sex-F"]) {
                                df = df.query({ column: "1", is: "==", to: "F" })
                            }
                            apply_func = (x) => {
                                if (x >= 18) { return 'A' }
                                if (x >= 16 && x < 18) { return 'B' }
                                if (x >= 14 && x < 16) { return 'C' }
                                if (x >= 12 && x < 14) { return 'D' }
                                if (x < 12) { return 'E' }
                            }
                            if (df.shape[0] == 396) {
                                col = 'G3'
                            } else { col = '32' }
                            console.log(df.shape);
                            output = df[col].apply(apply_func).value_counts();
                            index = output.index;

                            output = output.to_json({
                                download: false,
                                format: "row"
                            })[0];
                            var ddata = []
                            for (i = 0; i < index.length; i++) {
                                ddata.push({ group: index[i], value: output[i] });
                            }
                            updatebar(ddata)

                        })
                }
            }
        }
    </script>
</body>